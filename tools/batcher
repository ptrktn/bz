#!/usr/bin/expect
# -*-tcl-*-

proc err {msg} {
	puts stderr "Error: $msg"
	exit 1
}

proc dbg {msg} {
	global cfg

	puts stdout $msg
}

proc batcher_init {} {
	global cfg

	set cfg(inifile) {~/.batcherrc}
	set cfg(prompt) {[>$] }
	if {[file exists $cfg(inifile)]} {
		global cfg
		source $cfg(inifile)
	} else {
		err "init file not found"
	}

	dbg [array names cfg]
}

proc batcher_shell {args} {
	global cfg

	if {[llength $args] < 1} {
		err "shell: missing argument list"
	}

	foreach i $args {
		dbg "shell: $i"
	}

	set dst $cfg(dst)

	if {[info exists cfg($dst,gate)]} {
		set serv1 $cfg($dst,gate)
		set pass1 $cfg($dst,gate-passwd)
		set serv2 $cfg($dst,dst)
		set pass2 $cfg($dst,passwd)
	} else {
		set serv1 $cfg($dst,dst)
		set pass1 $cfg($dst,passwd)
	}

	spawn ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o CheckHostIP=no $serv1
	expect {password: }
	send "$pass1\r"
	expect $cfg(prompt)

	if {[info exists cfg($dst,gate)]} {
		send "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o CheckHostIP=no $serv2\r"
		expect {password: }
		send "$pass2\r"
		expect $cfg(prompt)
	}

	foreach i $args {
		send "$i\r"
		expect $cfg(prompt)
	}

	if {[info exists cfg($dst,gate)]} {
		send "exit\r"
	}

	send "exit\r"

	dbg "\nshell: completed"
}


proc batcher_get {args} {
	global cfg
	
	if {[llength $args] < 1} {
		err "get: missing argument list"
	}

	set dst $cfg(dst)

	# copy via gate server if used
	if {[info exists cfg($dst,gate)]} {
		set serv1 $cfg($dst,gate)
		set pass1 $cfg($dst,gate-passwd)
		set serv2 $cfg($dst,dst)
		set pass2 $cfg($dst,passwd)

		spawn ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o CheckHostIP=no $serv1
		expect {password: }
		send "$pass1\r"
		expect {$ }

		# FIXME use sftp
		foreach i $args {
			set fname [file tail $i]
		
			send "scp -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o CheckHostIP=no $serv2:$i .\r"
			expect {password: }
			send "$pass2\r"
			expect {$ }
			
			dbg "get: $i transfer to gate server completed"
		}

		send "exit\r"
		expect eof

		dbg "get: transfer of all files to gate server completed"
	}

	# copy from server or from gate server

	if {[info exists cfg($dst,gate)]} {
		set serv $cfg($dst,gate)
		set pass $cfg($dst,gate-passwd)		
	} else {
		set serv $cfg($dst,dst)
		set pass $cfg($dst,passwd)
	}
		
	spawn sftp -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o CheckHostIP=no $serv
	expect {password: }
	send "$pass\r"
	expect {sftp> }

	foreach i $args {
		if {[info exists cfg($dst,gate)]} {
			set fname [file tail $i]
		} else {
			set fname $i
		}

		send "get $fname\r"
		expect {sftp> }

		if {[info exists cfg($dst,gate)]} {
			send "rm $fname\r"
			expect {sftp> }
		}
	}

	send "quit\r"
	expect eof

	dbg "\nget: transfer completed"
}

# FIXME use sftp
proc batcher_put {args} {
	global cfg
	
	if {[llength $args] < 1} {
		err "put: missing argument list"
	}

	set dst $cfg(dst)

	foreach i $args {
		if {![file exists $i]} {
			err "put: file $i not found"
		}
		lappend fnames [file tail $i]
	}

	if {[info exists cfg($dst,gate)]} {
		set serv $cfg($dst,gate)
		set pass $cfg($dst,gate-passwd)
	} else {
		set serv $cfg($dst,dst)
		set pass $cfg($dst,passwd)
	}

	# copy to remote server or to gate server - mind the {*}
	# https://stackoverflow.com/questions/21407177/tcl-expect-multiple-files-w-scp
	spawn scp -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o CheckHostIP=no {*}$args $serv:
	expect {password: }
	send "$pass\r"

	# copy to final destination if gate server is used
	if {[info exists cfg($dst,gate)]} {

		dbg "\nput: [join $fnames] transfer to gate server completed"

		set serv1 $cfg($dst,gate)
		set pass1 $cfg($dst,gate-passwd)
		set serv2 $cfg($dst,dst)
		set pass2 $cfg($dst,passwd)

		spawn ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o CheckHostIP=no $serv1
		expect {password: }
		send "$pass1\r"
		expect {$ }
		send "scp -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o CheckHostIP=no [join $fnames] $serv2:\r"
		expect {password: }
		send "$pass2\r"
		expect {$ }
		send "rm -f [join $fnames]\r"
		expect {$ }
		send "exit\r"
	}

	dbg "\nput: transfer completed"
}

proc batcher_main {} {
    global argv
    global env
	global cfg

	batcher_init

    foreach i $argv {
		dbg "ARGV $i"
    }

	set dst [lindex $argv 0]
	set cmd [lindex $argv 1]

	dbg "dst $dst cmd $cmd"

	if {![info exists cfg($dst,dst)]} {
		err "$dst undefined"
	}

	if {[string compare [info procs "batcher_$cmd"] "batcher_$cmd"]} {
		err "$cmd undefined"
	}

	set cfg(dst) $dst

	eval batcher_$cmd [lrange $argv 2 end]
}

batcher_main

exit 0
